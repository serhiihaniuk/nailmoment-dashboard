// src/app/api/bot/route.ts

import { Bot, Context, InlineKeyboard, webhookCallback } from "grammy";
import { db } from "@/shared/db";
import { speakerVoteTGTable } from "@/shared/db/schema";
import { eq } from "drizzle-orm";
import { nanoid } from "nanoid";
import { SPEAKERS } from "@/shared/const";

const token = process.env.TG_BOT;
if (!token) throw new Error("BOT_TOKEN is unset");

const bot = new Bot(token);

const WELCOME_MESSAGE_PART_1 = `–ü—Ä–∏–≤—ñ—Ç! –Ø ‚Äî –±–æ—Ç Nail Moment, —ñ —è –¥–æ–ø–æ–º–æ–∂—É –≤–∏–∑–Ω–∞—á–∏—Ç–∏ –ø–µ—Ä–µ–º–æ–∂—Ü—è –∫–æ–Ω–∫—É—Ä—Å—É ¬´–ù–∞—Ä–æ–¥–Ω–∏–π —Å–ø—ñ–∫–µ—Ä¬ª, —è–∫–∏–π –ø—Ä–æ—Ö–æ–¥–∏—Ç—å —É —Ä–∞–º–∫–∞—Ö –ø—ñ–¥–≥–æ—Ç–æ–≤–∫–∏ –¥–æ –Ω–∞—à–æ–≥–æ —Ñ–µ—Å—Ç–∏–≤–∞–ª—é —É –í—Ä–æ—Ü–ª–∞–≤—ñ üíõüíÖ

üé§ –ü–µ—Ä–µ–º–æ–∂–µ—Ü—å –∫–æ–Ω–∫—É—Ä—Å—É –≤–∏—Å—Ç—É–ø–∏—Ç—å –Ω–∞ –≥–æ–ª–æ–≤–Ω—ñ–π —Å—Ü–µ–Ω—ñ Nail Moment 27 –ª–∏–ø–Ω—è 2025 —Ä–æ–∫—É –∑ –∞–≤—Ç–æ—Ä—Å—å–∫–æ—é —Ç–µ–º–æ—é, —è–∫–∞ –ø–µ—Ä–µ–º–æ–∂–µ —É –≥–æ–ª–æ—Å—É–≤–∞–Ω–Ω—ñ.`;

const WELCOME_MESSAGE_PART_2 = `üìπ –í—ñ–¥–µ–æ–ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü—ñ—ó —É—á–∞—Å–Ω–∏–∫—ñ–≤ —É–∂–µ –¥–æ—Å—Ç—É–ø–Ω—ñ! –ü–µ—Ä–µ–¥ —Ç–∏–º, —è–∫ –≥–æ–ª–æ—Å—É–≤–∞—Ç–∏, –æ–±–æ–≤‚Äô—è–∑–∫–æ–≤–æ –ø–µ—Ä–µ–≥–ª—è–Ω—å —É—Å—ñ –∑–∞—è–≤–∫–∏!

–ì–æ–ª–æ—Å—É–≤–∞–Ω–Ω—è –ø—Ä–æ—Ö–æ–¥–∏—Ç–∏–º–µ –≤ —Ü—å–æ–º—É —á–∞—Ç-–±–æ—Ç—ñ üí¨
–•—Ç–æ —Å—Ç–∞–Ω–µ –Ω–∞—Å—Ç—É–ø–Ω–æ—é –∑—ñ—Ä–∫–æ—é –Ω–∞—à–æ—ó —Å—Ü–µ–Ω–∏? –û–±–∏—Ä–∞—î—à —Å–∞–º–µ —Ç–∏!`;

function escapeMarkdownV2(text: string): string {
  const charsToEscape = /[_\[\]()~`>#+\-=|{}.!]/g;
  return text.replace(charsToEscape, (char) => `\\${char}`);
}

async function initiateVotingFlow(ctx: Context) {
  const telegramUserId = ctx.from!.id;
  try {
    const existingVote = await db
      .select()
      .from(speakerVoteTGTable)
      .where(eq(speakerVoteTGTable.telegram_user_id, telegramUserId))
      .limit(1);

    const votedForId =
      existingVote.length > 0 ? existingVote[0].voted_for_id : null;

    await ctx.reply(
      escapeMarkdownV2("–ë—É–¥—å –ª–∞—Å–∫–∞, –ø–µ—Ä–µ–≥–ª—è–Ω—å—Ç–µ –≤—ñ–¥–µ–æ —Ç–∞ –∑—Ä–æ–±—ñ—Ç—å —Å–≤—ñ–π –≤–∏–±—ñ—Ä:"),
      { parse_mode: "MarkdownV2" }
    );

    for (let i = 0; i < SPEAKERS.length; i++) {
      const videoNumber = i + 1;
      const speaker = SPEAKERS[i];
      let caption: string;
      let keyboard: InlineKeyboard;

      if (speaker.id === votedForId) {
        caption = escapeMarkdownV2(
          `‚úÖ –í–∏ –≤–∂–µ –ø—Ä–æ–≥–æ–ª–æ—Å—É–≤–∞–ª–∏ –∑–∞ –í—ñ–¥–µ–æ #${videoNumber}`
        );
        keyboard = new InlineKeyboard().text(
          "–°–∫–∏–Ω—É—Ç–∏ –º—ñ–π –≥–æ–ª–æ—Å üîÑ",
          `reset_vote:${videoNumber}`
        );
      } else {
        caption = escapeMarkdownV2(
          `–¶–µ –í—ñ–¥–µ–æ #${videoNumber} ‚Äî ${speaker.name}`
        );
        keyboard = new InlineKeyboard().text(
          `–ü—Ä–æ–≥–æ–ª–æ—Å—É–≤–∞—Ç–∏ –∑–∞ ${speaker.name} üëç`,
          `vote:${videoNumber}`
        );
      }

      await ctx.replyWithVideo(speaker.file_id, {
        caption: caption,
        reply_markup: keyboard,
        parse_mode: "MarkdownV2",
      });
      await new Promise((resolve) => setTimeout(resolve, 500));
    }
  } catch (error) {
    console.error("Error in initiateVotingFlow:", error);
    await ctx.reply("–í–∏–±–∞—á—Ç–µ, —Å—Ç–∞–ª–∞—Å—è –ø–æ–º–∏–ª–∫–∞. –°–ø—Ä–æ–±—É–π—Ç–µ –ø—ñ–∑–Ω—ñ—à–µ.");
  }
}

bot.command("start", async (ctx) => {
  await ctx.reply(escapeMarkdownV2(WELCOME_MESSAGE_PART_1), {
    parse_mode: "MarkdownV2",
  });

  const showVideosKeyboard = new InlineKeyboard().text(
    "–ü–æ–∫–∞–∑–∞—Ç–∏ –≤—ñ–¥–µ–æ –¥–ª—è –≥–æ–ª–æ—Å—É–≤–∞–Ω–Ω—è",
    "show_videos"
  );
  await ctx.reply(escapeMarkdownV2(WELCOME_MESSAGE_PART_2), {
    reply_markup: showVideosKeyboard,
    parse_mode: "MarkdownV2",
  });
});

bot.command("vote", (ctx) => initiateVotingFlow(ctx));

// --- NEW COMMAND HANDLER ---
bot.command("reset", async (ctx) => {
  const telegramUserId = ctx.from!.id;
  try {
    const existingVote = await db
      .select()
      .from(speakerVoteTGTable)
      .where(eq(speakerVoteTGTable.telegram_user_id, telegramUserId))
      .limit(1);

    let replyMessage: string;

    if (existingVote.length > 0) {
      await db
        .delete(speakerVoteTGTable)
        .where(eq(speakerVoteTGTable.telegram_user_id, telegramUserId));
      replyMessage =
        "–í–∞—à –ø–æ–ø–µ—Ä–µ–¥–Ω—ñ–π –≥–æ–ª–æ—Å –≤–∏–¥–∞–ª–µ–Ω–æ. –¢–µ–ø–µ—Ä –≤–∏ –º–æ–∂–µ—Ç–µ –≥–æ–ª–æ—Å—É–≤–∞—Ç–∏ –∑–Ω–æ–≤—É.";
    } else {
      replyMessage = "–£ –≤–∞—Å –Ω–µ–º–∞—î –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –≥–æ–ª–æ—Å—É, —è–∫–∏–π –º–æ–∂–Ω–∞ –±—É–ª–æ –± —Å–∫–∏–Ω—É—Ç–∏.";
    }

    const showVideosKeyboard = new InlineKeyboard().text(
      "–ü–æ–∫–∞–∑–∞—Ç–∏ –≤—ñ–¥–µ–æ –¥–ª—è –≥–æ–ª–æ—Å—É–≤–∞–Ω–Ω—è",
      "show_videos"
    );
    await ctx.reply(escapeMarkdownV2(replyMessage), {
      reply_markup: showVideosKeyboard,
      parse_mode: "MarkdownV2",
    });
  } catch (error) {
    console.error("Error in /reset command:", error);
    await ctx.reply("–í–∏–±–∞—á—Ç–µ, —Å—Ç–∞–ª–∞—Å—è –ø–æ–º–∏–ª–∫–∞ –ø—ñ–¥ —á–∞—Å —Å–∫–∏–¥–∞–Ω–Ω—è –≤–∞—à–æ–≥–æ –≥–æ–ª–æ—Å—É.");
  }
});
// -------------------------

bot.callbackQuery("show_videos", async (ctx) => {
  await ctx.answerCallbackQuery();
  await ctx.editMessageReplyMarkup();
  await initiateVotingFlow(ctx);
});

bot.callbackQuery(/^vote:(\d+)$/, async (ctx) => {
  const telegramUserId = ctx.from!.id;
  const videoNumber = parseInt(ctx.match[1], 10);
  const votedForId = `video_${videoNumber}`;
  const existingVote = await db
    .select()
    .from(speakerVoteTGTable)
    .where(eq(speakerVoteTGTable.telegram_user_id, telegramUserId))
    .limit(1);
  if (existingVote.length > 0) {
    await ctx.answerCallbackQuery({
      text: "–í–∏ –≤–∂–µ –ø—Ä–æ–≥–æ–ª–æ—Å—É–≤–∞–ª–∏. –°–ø–æ—á–∞—Ç–∫—É —Å–∫–∏–Ω—å—Ç–µ –ø–æ–ø–µ—Ä–µ–¥–Ω—ñ–π –≥–æ–ª–æ—Å.",
    });
    return;
  }
  try {
    await db.insert(speakerVoteTGTable).values({
      id: nanoid(),
      telegram_user_id: telegramUserId,
      voted_for_id: votedForId,
    });
    await ctx.answerCallbackQuery({ text: "–î—è–∫—É—é! –í–∞—à –≥–æ–ª–æ—Å –∑–±–µ—Ä–µ–∂–µ–Ω–æ." });
    const resetKeyboard = new InlineKeyboard().text(
      "–°–∫–∏–Ω—É—Ç–∏ –º—ñ–π –≥–æ–ª–æ—Å üîÑ",
      `reset_vote:${videoNumber}`
    );
    await ctx.editMessageCaption({
      caption: escapeMarkdownV2(
        `‚úÖ –ü—Ä–æ–≥–æ–ª–æ—Å–æ–≤–∞–Ω–æ! üî•üî•üî• 

        –í–∏ –æ–±—Ä–∞–ª–∏ –í—ñ–¥–µ–æ #${videoNumber}`
      ),
      reply_markup: resetKeyboard,
      parse_mode: "MarkdownV2",
    });
  } catch (error) {
    console.error("Error processing vote:", error);
    await ctx.answerCallbackQuery({
      text: "–°—Ç–∞–ª–∞—Å—è –ø–æ–º–∏–ª–∫–∞, –∞–±–æ –≤–∏ –≤–∂–µ –ø—Ä–æ–≥–æ–ª–æ—Å—É–≤–∞–ª–∏.",
      show_alert: true,
    });
  }
});

bot.callbackQuery(/^reset_vote:(\d+)$/, async (ctx) => {
  const telegramUserId = ctx.from!.id;
  const videoNumber = parseInt(ctx.match[1], 10);
  try {
    await db
      .delete(speakerVoteTGTable)
      .where(eq(speakerVoteTGTable.telegram_user_id, telegramUserId));
    await ctx.answerCallbackQuery({
      text: "–í–∞—à –≥–æ–ª–æ—Å —Å–∫–∏–Ω—É—Ç–æ! –¢–µ–ø–µ—Ä –≤–∏ –º–æ–∂–µ—Ç–µ –≥–æ–ª–æ—Å—É–≤–∞—Ç–∏ –∑–Ω–æ–≤—É.",
    });
    const voteKeyboard = new InlineKeyboard().text(
      "–ü—Ä–æ–≥–æ–ª–æ—Å—É–≤–∞—Ç–∏ –∑–∞ —Ü–µ üëç",
      `vote:${videoNumber}`
    );
    await ctx.editMessageCaption({
      caption: escapeMarkdownV2(`–¶–µ –í—ñ–¥–µ–æ #${videoNumber}`),
      reply_markup: voteKeyboard,
      parse_mode: "MarkdownV2",
    });
  } catch (error) {
    console.error("Error resetting vote:", error);
    await ctx.answerCallbackQuery({
      text: "–ü–æ–º–∏–ª–∫–∞ –ø—ñ–¥ —á–∞—Å —Å–∫–∏–¥–∞–Ω–Ω—è –≥–æ–ª–æ—Å—É.",
      show_alert: true,
    });
  }
});

bot.on("message:video", async (ctx) => {
  const fileId = ctx.message.video.file_id;
  const safeText = escapeMarkdownV2(`–û—Ç—Ä–∏–º–∞–Ω–æ –≤—ñ–¥–µ–æ. \n\n–í–∞—à file_id: `);
  await ctx.reply(`${safeText}\`${fileId}\``, { parse_mode: "MarkdownV2" });
});

bot.on("message:text", async (ctx) => {
  await ctx.reply(
    escapeMarkdownV2(
      "–ë—É–¥—å –ª–∞—Å–∫–∞, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É /start, —â–æ–± —Ä–æ–∑–ø–æ—á–∞—Ç–∏."
    )
  );
});

export const POST = webhookCallback(bot, "std/http");
